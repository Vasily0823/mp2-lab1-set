// ННГУ, ВМК, Курс "Методы программирования-2", С++, ООП
//
// tset.cpp - Copyright (c) Гергель В.П. 04.10.2001
//   Переработано для Microsoft Visual Studio 2008 Сысоевым А.В. (19.04.2015)
//
// Множество - реализация через битовые поля

#include "tset.h"

TSet::TSet(int mp) :BitField(mp)//конструктор . список инициализации
{
	MaxPower = mp;
}

/*
Метод вызывает конструктор BitField(mp) класса bitfield:
“Конструктор TBitField::TBitField(int mp)
При попытке создания поля отрицательной длины, срабатывает исключение:
throw invalid_argument("Len<0...")
Переменная bits типа TELEM инициализируется для хранения количества элементов памяти TELEM, необходимого для хранения 
битового поля и инициализируется следующим образом:
bits = (mp + (BitInTELEM - 1)) / BitInTELEM
Из количества бит в ячейке памяти TELEM на текущей аппаратной машине (BitInTELEM), вычитается единица (BitInTELEM - 1) и 
добавляется  длина битового поля, затем в переменную bits сохраняется целая цасть от деления этого значения на BitInTELEM. 
Другими словами при значении BitInTELEM=32:
Len = 0;  bits = (0 + (32 - 1)) / 32 = 31 / 32=0 ячеек TELEM
Len = 1;  bits = (1 + (32 - 1)) / 32 = 32 / 32=1 ячеек TELEM
…
Len = 32;  bits = (32 + (32 - 1)) / 32 = 63 / 32=1 ячеек TELEM
Len = 33;  bits = (33 + (32 - 1)) / 32 =  64/ 32=2 ячеек TELEM
Затем в аргументы MemLen и BitLen из private секции класса инициализируются значениями bits и mp соответственно. Затем 
выделяется MemLen ячеек TELEM памяти и каждый бит ячейки инициализируется нулем за счет для присваивания pMem[i] = 0 
для i={1,…,MemLen}”
Так же метод инициализирует переменную MaxPower из private секции класса tset, переданным значением mp.
*/

TSet::TSet(const TSet &s) : BitField(s.BitField)// конструктор копирования
{
	MaxPower = s.MaxPower;
}

/*
Конструктор копирования TSet::TSet(const TSet &s) : BitField(s.BitField)
Метод вызывает конструктор копирования BitField(s.BitField) класса bitfield:
“ Конструктор копирования TBitField::TBitField(const TBitField & s.BitField)
Аргументы MemLen и BitLen из private секции класса инициализируются полученными от объекта 
значениями s.BitField.MemLen и s.BitField.BitLen соответственно. Затем выделяется MemLen ячеек TELEM памяти и 
каждый бит ячейки инициализируется нулем за счет для присваивания pMem[i] = 0 для i={1,…,MemLen}”
Так же метод инициализирует переменную MaxPower из private секции класса tset, значением s.MaxPower.
*/

TSet::TSet(const TBitField &bf) : BitField(bf)// конструктор преобразования типа
{
	MaxPower = bf.GetLength();
}

/*
Конструктор преобразования типа TSet::TSet(const TBitField &bf) : BitField(bf)
Метод вызывает конструктор копирования TBitField(const TBitField &bf) класса bitfield:
“конструктор копирования TBitField::TBitField(const TBitField &bf)
Аргументы MemLen и BitLen из private секции класса инициализируются полученными от объекта значениями 
bf.MemLen и bf.BitLen соответственно. Затем выделяется MemLen ячеек TELEM памяти и каждый бит ячейки инициализируется 
нулем за счет для присваивания pMem[i] = 0 для i={1,…,MemLen}”
Так же метод инициализирует переменную MaxPower из private секции класса tset, значением s.MaxPower.
*/

TSet::operator TBitField() // оператор преобразования к TBitField/ получить битфилд
{
	TBitField result(BitField);
	return result;
}
/*
Метод возвращает объявляет битовое поле result, которое инициализировано с помощью конструктора 
преобразования типа TSet::TSet(const TBitField &bf) : BitField(bf).
*/

int TSet::GetMaxPower(void) const // Максимальная мощность множества/получить макс. к-во эл-тов. получить мощность
{
	return MaxPower;
}
/*
Метод возвращает максимальную мощность множества MaxPower.
*/

int TSet::IsMember(const int Elem) const // Проверить наличие элемента в множестве/элемент множества?.. получить значение бита
{
	return BitField.GetBit(Elem);
}

/*
Метод вызывает метод класс предка GetBit:
“Получить значение бита в битовом поле int TBitField::GetBit(const int n) const
При попытке получить бит с отрицательным индексом, срабатывает исключение:
throw invalid_argument("Len<0...")
При попытке получить бит с индексом большим, чем битов в поле, срабатывает исключение:
throw invalid_argument("BitLen < n...")
Метод получает значение бита следующим образом:
if ((pMem[GetMemIndex(n)] & GetMemMask(n)) == 0) return 0;
else return 1;
Для бита n с помощью GetMemIndex(n), метод находит индекс элемента TELEM. Для бита n с помощью GetMemMask(n), метод находит необходимую маску. После чего на найденный элемент TELEM и найденную маску метод воздействует логической операцией “И ”, если в результат воздействия логической операцией “И ” – 1, то метод возвращает единицу, в противном случае метод возвращает 0.”
Если элемент содержится во множестве, то, после проверки соответствующего элемента характеристического вектора, метод вернет единицу, в противном случае – ноль.

*/

void TSet::InsElem(const int Elem) // Включить элемент в множество . в 1
{
	BitField.SetBit(Elem);
}
/*
Метод вызывает метод класс предка SetBit:
“Установить бит в битовом поле void TBitField::SetBit
По источнику [1]:
“Для установки битов выполняют логическое сложение (операцию «битовое ИЛИ») числа x с маской, у которой в позициях, соответствующих битовому полю, установлены единицы. Пример установки бита однобитового поля a: x1 = x | 00000001b”
При попытке установить биту с отрицательным индексом значение, срабатывает исключение:
throw invalid_argument("Len<0...")
При попытке установить значение биту с индексом большим, чем битов в поле, срабатывает исключение:
throw invalid_argument("BitLen < n...")
Бит устанавливается следующим образом:
pMem[GetMemIndex(n)] = pMem[GetMemIndex(n)] | GetMemMask(n)
Для бита n с помощью GetMemIndex(n), метод находит индекс элемента TELEM. Для бита n с помощью GetMemMask(n), метод находит необходимую маску. После чего на найденный элемент TELEM и найденную маску метод воздействует логической операцией “ИЛИ””
По окончанию действия метода соответствующий элемент характеристического вектора примет значение единица.
*/

void TSet::DelElem(const int Elem) //Удалить элемент из множества . в 0
{
	BitField.ClrBit(Elem);
}

/*
Удалить элемент из множества void TSet::DelElem(const int Elem)
Метод вызывает метод класс предка ClrBit:
“Очистить бит в битовом поле void TBitField::ClrBit(const int n)
По источнику [1]:
“Для установки в один или несколько битов нулей число x операцией «битовое И» умножают на маску, у которой в позициях, соответствующих битовому полю, установлены нулевые биты. Пример установки нулей в биты битового поля b: x3 = x & 11111101b”
При попытке сбросить бит с отрицательным индексом, срабатывает исключение:
throw invalid_argument("Len<0...")
При попытке сбросить бит с индексом большим, чем битов в поле, срабатывает исключение:
throw invalid_argument("BitLen < n...")
Бит сбрасывается следующим образом:
pMem[GetMemIndex(n)] = pMem[GetMemIndex(n)] & ~GetMemMask(n);
Для бита n с помощью GetMemIndex(n), метод находит индекс элемента TELEM. Для бита n с помощью GetMemMask(n), метод находит необходимую маску. После чего на найденный элемент TELEM и найденную маску метод воздействует логической операцией “И””
По окончанию действия метода соответствующий элемент характеристического вектора примет значение ноль.
*/

// -------------------------теоретико-множественные операции

TSet& TSet::operator=(const TSet &s) // присваивание перегрузка
{
	BitField = s.BitField;
	MaxPower = s.GetMaxPower();
	return *this;
}
/*
Метод инициализирует переменные из секции private класса tset BitField и MaxPower значениями s.BitField и 
s.GetMaxPower() соответственно. После чего метод возвращает полученное множество.
*/

int TSet::operator==(const TSet &s) const // сравнение перегрузка
{
	return BitField == s.BitField; //перегружено в битфилд
}

/*
Метод сравнивает два битовых поля BitField и s.BitField;, использую перегруженный в классе-предке опрератор “==”:
“Метод объявляет и инициализирует единицей переменную result. Если битовые поля имею разную длину, то переменная 
result инициализируется нулем, и это значение возвращается методом. Если битовые поля имеют одинаковую длину, то поля
сравниваются поэлементно с помощью метода GetBit, и, в случае неравенства элемента GetBit(i) элементу bf.GetBit(i), 
переменная result инициализируется нулем. По завершению проверки метод возвращает переменную result.”
Метод вернет единицу в случае равенства битовых полей, в противном случае – ноль.
*/

int TSet::operator!=(const TSet &s) const // сравнение
{
	return BitField != s.BitField; //перегружено в битфилд
}

/*
Метод сравнивает два битовых поля BitField и s.BitField;, использую перегруженный в классе-предке опрератор “!=”:
“Метод объявляет и инициализирует нулем переменную result. Если битовые поля имею разную длину, то переменная result инициализируется единицей, и это значение возвращается методом. Если битовые поля имеют одинаковую длину, то поля сравниваются поэлементно с помощью метода GetBit, и, в случае неравенства элемента GetBit(i) элементу bf.GetBit(i), переменная result инициализируется единицей. По завершению проверки метод возвращает переменную result.”
Метод вернет единицу в случае неравенства битовых полей, в противном случае – ноль.
*/

TSet TSet::operator+(const TSet &s) // объединение со всем полем
{
	TSet result(BitField | s.BitField); //перегружено в битфилд
	return result;
}

/*
Метод объявляет множество, которое заполняется при при помощи перегруженного в классе-предке оператора “|”:
“Метод объявляет и инициализирует нулем переменную result. Если битовые поля имею разную длину, то 
переменная result инициализируется единицей, и это значение возвращается методом. Если битовые поля имеют 
одинаковую длину, то поля сравниваются поэлементно с помощью метода GetBit, и, в случае неравенства элемента GetBit(i) 
элементу bf.GetBit(i), переменная result инициализируется единицей. По завершению проверки метод возвращает переменную result.”
Метод возвращает полученное множество.
*/

TSet TSet::operator+(const int Elem) // объединение с одним элементом элметом
{
	if (Elem > BitField.GetLength())
	{
		throw ("Elem > Length");
	}
	TBitField temp(MaxPower);
	temp.SetBit(Elem);
	TSet result(BitField | temp); //перегружено в битфилд
	return result;
}

/*Метод сравнивает длины объединяемых множеств и в случае их неравенства обрабатывает исключением throw 
("Elem > Length"). В случае равенства множеств, метод объявляет битовое поле temp длиной MaxPower, устанавливает
равное единице значение в соответствующий элемент характеристического вектора и инициализирует объявленное множество 
result значениями, полученными в результате воздействия на битовые поля BitField и temp логической операцией “или”.
Метод возвращает полученное множество.*/

TSet TSet::operator-(const int Elem) // разность с элементом
{
	if (Elem > BitField.GetLength())
	{
		throw ("Elem > Length");
	}
	TBitField temp(MaxPower);
	temp.SetBit(Elem);
	TSet result(BitField & temp); //перегружено в битфилд
	return result;
}
/*
Метод сравнивает длины объединяемых множеств и в случае их неравенства обрабатывает исключением 
throw ("Elem > Length"). В случае равенства множеств, метод объявляет битовое поле temp длиной MaxPower,
устанавливает равное единице значение в соответствующий элемент характеристического вектора и инициализирует 
объявленное множество result значениями, полученными в результате воздействия на битовые поля BitField и temp логической 
операцией “И”. Метод возвращает полученное множество.
*/

TSet TSet::operator*(const TSet &s) // пересечение
{
	TSet result(BitField & s.BitField);
	return result;
}

/*
Метод возвращает множество, полученное в результате воздействия на битовые 
поля BitField и s.BitField логической операцией “И”.
*/

TSet TSet::operator~(void) // дополнение .. инфверсия
{
	TSet result(~BitField); //перегружено в битфилд
	return result;
}

/*
Метод возвращает множество, полученное в результате воздействия на битовое поляе BitField 
логической операцией “отрицание”.
*/

// ------------------------------перегрузка ввода/вывода

istream &operator>>(istream &istr, TSet &s) // ввод {s1,s2,s3}
{
	char c;
	printf("__Input set\n");
	printf("lenght of set = %i\n", s.GetMaxPower());
	for (int i = 0; i < s.GetMaxPower(); i++)
	{
		printf("set(%i) = ", i);
		istr >> c;
		if (c == '1') s.InsElem(i); else s.DelElem(i);
	}
	printf("end.\n\n");
	return istr;
}

/*
Метод объявляет переменную char c и информирует пользователя о начале ввода множества (s) и 
о его мощности (s.GetMaxPower). После чего метод считывает нажатия пользователя. Если пользователь ввел единицу,
то  соответствующий элементу множества элемент характеристического вектора будет инициализирован единицей 
(с помощью метода s.InsElem(i)), в противном случае значение будет инициализировано нулем(с помощью метода s.DelElem(i)).
*/

ostream& operator<<(ostream &ostr, const TSet &s) // вывод
{
	ostr << "__Print set" << endl;
	ostr << "lenght of set = " << s.GetMaxPower() << endl;
	for (int i = 0; i < s.GetMaxPower(); i++)
		ostr << "set(" << i << ")= " << s.IsMember(i) << endl;
	ostr << "end." << endl << endl;
	return ostr;
}

/*
Метод информирует пользователя о начале вывода множества (s) и о его мощности (s.GetMaxPower). 
После чего метод поочередно с новой строки выводит значение характеристического вектора, соответствующее
текущему элементу множества (с помощью метода s.IsMember(i)).
*/